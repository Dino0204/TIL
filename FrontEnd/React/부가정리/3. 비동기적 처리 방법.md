## CallBack

---

### 개념

- 다른 함수가 실행을 마친 뒤 실행되는 함수
  이벤트가 발생, 특정 시점에 도달 했을 때 호출하는 함수
- 매개변수로 함수를 전달받아 함수 내부에서 실행됨

### 사용이유

- 비동기적 프로그래밍을 할 수 있기 때문에
  → JS는 메인 스레드(이벤트 루프)가 싱글스레드이기 때문에 비동기적 작업을 수행할 수 없음
  → 외부의 멀티 스레드를 통해 비동기작업을 수행 할 수 있는데 콜백 패턴을 통해 이 작업을 수행함

### 콜백 패턴

```jsx
getData("step", (a) => {});
```

- 기대와 다르게 동작함

  - 비동기 함수를 호출하면 함수 내부의
    비동기로 동작하는 코드가 완료되지 않아도 종료됨 1. 상위 스코프 변수에 할당
    비동기로 동작하는 onload 이벤트 헨들러는
    Call Stack의 모든 실행 컨텍스트(getData, console.log) 종료 후 실행

        2. 서버 응답을 반환

            onload 이벤트 헨들러를 getData함수가 호출하지
            않기 때문에 반환값을 받을 수 없음

- 따라서 비동기 함수의 처리 결과의 후속처리는
  비동기 함수 내부(CallBack 함수)에서만 수행해야 한다

- CallBack Hell
  비동기 함수가 처리결과를 가지고 다시
  CallBack 함수를 호출하는 것 (복잡도가 증가함) - 단점 1. 가독성을 나쁘게함 2. 에러 처리가 곤란함

## Promise

---

콜백 패턴의 단점을 해결하기 위해 도입됨

### 생성

- Promise 생성자를 new를 통해 Promise 객체를 생성
- Promise 생성자는 비동기 처리를 수행할
  resolve, reject CallBack 함수를 인수로 전달받음

```jsx
const Promise = new Promise((resolve,reject)=>{
	// CallBack 함수 내부에서 비동기 처리 수행
	if(/* 비동기 처리 성공 */){
		resolve('success')
	}else{
		reject('fail')
	}
})
```

- 비동기 함수
  promiseGetData : 함수 내에서 프로미스 생성 및 반환
- 비동기 처리
  - Promise 생성자가 인수로 전달받은
    콜백 함수 내부에서 수행
  - 현재 상태정보를 가짐
    | 상태 정보 | 의미 | 상태 변경 조건 |
    | --------- | --------- | ---------------------------- |
    | pending | 수행전 | 프로미스 생성 직후 기본 상태 |
    | |
    | fulfilled | 수행 성공 | resolve 호출 |
    | rejected | 수행 실패 | resolve 호출 |

→ 비동기 처리 상태, 결과를 관리하는 객체

### 후속 처리 메서드

- 비동기 처리 상태 변화에 따라 후속 처리를 해야함
  → then, catch, finally 제공
- 위 메서드들은 프로미스를 반환함(비동기 동작)

1. then
   1.
2. catch
   1.
3. finally
   1.

### 에러 처리

### 체이닝

### 정적 메서드

### 마이크로태스크 큐

## Async & Await

---

## 참고자료

- [https://velog.io/@dbwjd5864/자바스크립트의-프로미스-Promise는-무엇일까요](https://velog.io/@dbwjd5864/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%9D%98-%ED%94%84%EB%A1%9C%EB%AF%B8%EC%8A%A4-Promise%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C%EC%9A%94)
